---
title: gRPC 등장배경
layout: post
tag: [gRPC]
toc: true
---

## gRPC 소개

gRPC(google Remote Procedure Call)란 구글에서 만든 원격 프로시저 호출 프레임워크입니다. gRPC가 왜 등장했는지 알아보기 위해 프로세스간 통신의 역사를 알아야 할 필요가 있습니다.

## 등장배경 

### RPC(Remote Procedure Call)
RPC는 프로세스 간 통신을 추상화하여, 프로세스가 동일한 시스템에 있는 것처럼 편리하게 작업을 수행할 수 있게 해주었습니다. 이는 다른 프로세스와 통신할 때 마치 동일한 프로세스 내에서 함수를 호출하는 것처럼 작업을 수행할 수 있게 해주었습니다.

그러나 RPC는 통신 할 때 데이터 형식에 대한 명세가 필요했고, 복잡한 시스템에 대한 확장성과 유지 보수성에 어려움이 있었습니다. 데이터 형식에 대한 명세는 프로그래머가 직접 작성해야 했으며, 이는 많은 시간과 노력을 필요로 했습니다. 또한, 복잡한 시스템에 대한 확장성과 유지 보수성에 대한 문제는 시스템이 커질수록 더욱 심화되었습니다.

### SOAP(Simple Object Access Protocol)
이런 문제점들을 해결하기 위해 SOAP(Simple Object Access Protocol)가 등장했습니다. SOAP는 HTTP를 기반으로 한 프로토콜로, XML을 이용하여 데이터를 교환합니다. XML은 데이터 형식에 대한 명세를 자동으로 생성할 수 있게 해주었으며, 이로 인해 프로그래머의 부담을 줄여주었습니다. 또한, HTTP를 기반으로 하므로 기존의 웹 인프라를 그대로 사용할 수 있었습니다.

그러나 XML의 복잡성과 무거워짐으로 인해 많은 비효율성이 발생했습니다. XML은 데이터를 표현하는 데 필요한 태그가 많아 데이터의 크기가 커지는 문제가 있었습니다. 또한, XML을 파싱하는 과정에서 CPU와 메모리를 많이 소모하여 시스템의 성능을 저하시켰습니다.

### REST(Representational State Transfer)
이런 문제점들을 해결하기 위해 REST(Representational State Transfer)가 등장했습니다. REST는 HTTP 메소드를 이용하여 CRUD(Create, Read, Update, Delete) 작업을 수행하며 JSON 형식으로 데이터를 교환합니다. JSON은 XML보다 간결하고 가벼워, 데이터 교환의 효율성을 높여주었습니다.

하지만 REST에도 한계가 있었습니다. REST는 상태를 가지지 않는(stateless) 통신방식이기 때문에, 연결상태를 유지하기 어렵고, 서버와 클라이언트 간의 통신 효율성이 떨어집니다. 이는 매 요청마다 연결을 새로 맺어야 하고, 이로 인해 네트워크 지연이 발생하며, 통신 효율성이 떨어진다는 단점이 있습니다.


### gRPC(google Remote Procedure Call)
이런 한계를 극복하기 위해 Google에서는 gRPC를 개발하였습니다. gRPC는 HTTP/2를 기반으로 하며, 데이터를 교환할 때 Protocol Buffers를 이용합니다. HTTP/2는 한 연결에서 여러 요청을 동시에 처리할 수 있는 다중화를 지원하며, 이로써 네트워크 지연을 줄일 수 있습니다. 또한, Protocol Buffers는 데이터 형식에 대한 명세를 자동으로 생성하고, 이를 이용해 데이터를 직렬화하고 역직렬화할 수 있습니다. 이로써 gRPC는 빠른 속도와 효율적인 데이터 교환을 제공하며, 다양한 언어에서 사용할 수 있습니다.


## 서비스 정의
gRPC에서 서비스는 Protocol Buffers의 `.proto` 파일에서 정의됩니다. 이 `.proto` 파일은 서비스들과 그 서비스들이 제공하는 메서드들, 그리고 메서드들이 받는 입력과 반환하는 출력의 타입 등을 정의하는데 사용됩니다. 서비스 정의는 특정 함수를 호출하기 위한 규약, 즉 RPC 메서드들의 집합을 포함하며, 각 메서드는 입력 타입과 출력 타입으로 서술됩니다. 이러한 방식은 프로그래머에게 명확한 인터페이스를 제공합니다.

![gRPC 기반 서비스 정의](https://github.com/hobit22/hobit22.github.io/assets/40729223/38d7ab38-538c-4768-8ccc-81f21a3cf87c)


gRPC는 정적 타이핑을 지원하므로, 컴파일 타임에 오류를 최소화하고, API를 매끄럽게 사용할 수 있게 합니다. 이는 특히 복잡한 시스템에서 유용하며, 오류 발생 가능성을 줄이고 개발 시간을 단축시킵니다.

## gRPC의 장단점

### 장점

1. **효율적인 데이터 교환**: gRPC는 Protocol Buffers를 이용하여 데이터를 직렬화하고 역직렬화합니다. 직렬화는 복잡한 데이터 구조를 바이트 스트림으로 변환하는 과정이며, 역직렬화는 이 바이트 스트림을 다시 원래의 데이터 구조로 변환하는 과정입니다. 이 과정을 통해 데이터 교환의 효율성이 높아집니다.
2. **다양한 언어 지원**: gRPC는 다양한 언어를 지원하여, 다양한 언어로 작성된 서비스 간의 통신이 가능합니다. 이는 다양한 환경과 플랫폼에서 사용 가능하게 하며, 여러 언어로 구성된 시스템 간의 통신을 용이하게 합니다.
3. **HTTP/2 지원**: gRPC는 HTTP/2를 기반으로 합니다. HTTP/2는 한 연결에서 여러 요청을 동시에 처리할 수 있는 다중화를 지원하므로, 네트워크 지연을 줄일 수 있습니다. 이는 효율적인 네트워크 통신을 가능하게 합니다.

### 단점

1. **학습 곡선**: gRPC와 Protocol Buffers의 개념을 익히는 데에는 시간이 필요할 수 있습니다. 이는 새로운 기술을 배우는 데 있어서의 일반적인 문제이며, 잘 문서화된 자료와 커뮤니티의 도움을 받아 극복할 수 있습니다.
2. **브라우저 지원**: gRPC는 HTTP/2를 기반으로 하지만, 모든 브라우저가 HTTP/2를 완전히 지원하지는 않습니다. 이는 일부 환경에서 gRPC의 사용을 제한할 수 있습니다.
3. **디버깅의 어려움**: Protocol Buffers의 이진 형식 때문에, HTTP와 JSON을 사용하는 RESTful API에 비해 디버깅이 어렵습니다. 이진 형식은 사람이 읽을 수 없으므로, 데이터를 확인하거나 문제를 찾는데 어려움이 있을 수 있습니다.